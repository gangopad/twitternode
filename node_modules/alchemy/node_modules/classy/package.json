{
  "name": "classy",
  "version": "1.4.10",
  "scripts": {
    "build": "browserify src/index.js -s classy o-np dist/classy.js",
    "watch": "watchify src/index.js -s classy -o dist/classy.js",
    "dev": "npm run build | npm run watch",
    "test": "karma start",
    "start": "python -m SimpleHTTPServer"
  },
  "main": "src/index.js",
  "description": "Classy - Classes for JavaScript",
  "directories": {
    "test": "test"
  },
  "devDependencies": {
    "browserify": "^3.44.2",
    "watchify": "~0.8.2",
    "karma": "~0.12.14",
    "karma-jasmine": "~0.1.5",
    "karma-chrome-launcher": "~0.1.3",
    "should": "~4.0.4",
    "mocha": "~1.21.4"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/classyjs/classy.git"
  },
  "keywords": [
    "class",
    "super",
    "method",
    "classes",
    "inheritance",
    "hierarchy",
    "mixins",
    "override"
  ],
  "author": {
    "name": "Radu Brehar"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/classyjs/classy/issues"
  },
  "homepage": "https://github.com/classyjs/classy",
  "dependencies": {
    "newify": "~1.1.9",
    "copy-utils": "~1.0.0"
  },
  "readme": "Classy - Smart JavaScript classes\n=================================\n\nClassy offers the ability to easily define classes, call super or overriden methods, define static properties, and mixin objects in a very flexible way.\n\nMeant to be used in the browser and in node. Well tested, with 50+ tests.\n\n## Installation\n\n```sh\n$ npm install classy\n```\nFor the browser please either use `webpack` or `browserify` to integrate classy into your app.\n<!--\n```\ndist/classy.js\n```\n -->\n\n## Contributing\n\nSee [CONTRIBUTING.md](./CONTRIBUTING.md)\n\n## Example\n```js\nvar Vehicle = classy.define({\n    alias: 'vehicle',\n\n    init: function(year){\n        this.year = year\n    }\n})\n\nvar Car = classy.define({\n    extend: 'vehicle' //or extend: Vehicle\n    alias : 'car',\n    forceInstance: true, // <- in order to force instantiation, even without 'new'\n\n    init: function(year, make){\n        this.callSuper() // <- notice how easy it can be!\n        this.make = make\n    },\n\n    getName: function(){\n        return this.make\n    }\n})\n\nvar ford = new Car(1980, 'Ford')\nconsole.log(ford.year)\nconsole.log(ford.make)\nvar bmw = Car(1990, 'Bmw') // <- since forceInstance is true, the constructor will be called with new under the hood\n```\n\nNotice the ```callSuper()``` method call, which can be used in any class method, and will call the method with the same name found on the super class. It also automatically sends all the arguments, so you don't have to manually do so.\n\n```js\nford.getName() === 'Ford' //is true\n```\n\n```js\nclassy.override('car', {\n    getName: function(){\n        return this.callOverriden() + ', made in ' + this.year\n    }\n})\n//now\nford.getName() === 'Ford, made in 1980' //is true\n```\n\nYou can use the class ```alias``` in order to easily reference which class you want to extend or override. This also helps you get a reference to your class by\n```js\n    var Car = classy.getClass('car')\n    var Vehicle = classy.getClass('vehicle')\n```\n\n\n## Aliases\n\nWhen defining a class, you can specify a string property named `alias`.\n\n`classy` keeps a reference to each class based on the specified alias. If no alias is given, one is generated anyway.\n\nUsing the alias allows you to reference, extend or override a class by the alias, without the need for an explicit reference to the class.\n\nExample\n```js\nclassy.define({\n  alias: 'shape'\n})\n\nclassy.define({\n  alias: 'rectangle',\n  extend: 'shape'\n})\n\nclassy.override('rectangle', {\n  getArea: function(){ /*... */}\n})\n```\n\nNotice that when defining the rectangle class, instead of saying we extend the Shape class, by a direct reference, we can use the alias of the Shape class, which is a string.\n\nWhenever an alias is expected, you can use either the alias, or the class itself (in classy.define, classy.override, classy.getClass, etc)\n\n## Override and callOverriden\n\nOverriding is simple, just call `classy.override` with the class alias or the class reference as the first param, and an object with properties to override as a second param.\n```js\nclassy.override(Car, {\n    getName: function(){\n        return this.callOverriden() + ', great car'\n    }\n})\n```\nor, if you don't have a reference to the class, but only have the alias\n```js\nclassy.override('car', {\n    getName: function(){\n        return this.callOverriden() + ', great car'\n    }\n})\n```\n\n## ```init``` as constructor\n\nUse the ```init``` method as the constructor\n\nExample\n\n```js\nvar Animal = classy.define({\n\n    //when a new Animal is created, the init method is called\n    init: function(config){\n        config = config || {}\n\n        //we simply copy all the keys onto this\n        Object.keys(config).forEach(function(key){\n            this[key] = config[key]\n        }, this)\n    }\n})\n\nvar Cat = classy.define({\n    extend: Animal,\n    alias: 'cat',\n\n    init: function(){\n        this.callSuper()\n        this.sound = 'meow'\n    },\n\n    getName: function(){\n        return this.name\n    }\n})\n\nvar lizzy = new Cat({ name: 'lizzy' })\n```\n\nYou can even extend functions/classes not defined with `classy`\n\n```js\nfunction Animal(sound){\n    this.sound = sound\n}\n\nAnimal.prototype.makeSound = function(){\n    return 'I sound like this: ' + this.sound\n}\n\nvar Dog = classy.define({\n    extend: Animal,\n    alias: 'dog',\n    init: function(){\n        this.callSuperWith('bark') //this calls Animal fn\n    }\n})\n\nvar dog = new Dog()\ndog.makeSound() == 'I sound like this: bark' // is true\n```\n\n## ```callSuper``` and ```callOverriden```\n\nUse the ```callSuper``` and ```callOverriden``` methods to call the super and overriden methods. You don't have to worry about forwarding the arguments, since this is handled automagically for you.\n\nIf there is no super or overriden method with the same name you don't have to worry either, since callSuper and callOverriden won't break. they will simply and silently do nothing\n\nExample\n```js\n    //create a shape class\n    classy.define({\n        alias: 'shape',\n\n        getDescription: function(){\n            return this.name\n        }\n    })\n\n    //create a rectangle class with a width and a height\n    classy.define({\n        extend: 'shape',\n        alias: 'rectangle',\n\n        name: 'rectangle',\n        init: function(size){\n            this.width = size.width\n            this.height = size.height\n        },\n\n        getArea: function(){\n            return this.width * this.height\n        },\n\n        setHeight: function(h){ this.height = h },\n        setWidth: function(w){ this.width = w }\n    })\n\n    classy.override('rectangle', {\n        getDescription: function(){\n            //reimplement the getDescription, but use the overriden implementation as well\n            return 'this is a ' + this.callOverriden()\n        }\n    })\n\n    //create a square class\n    classy.define({\n        extend: 'rectangle',\n        alias: 'square',\n\n        init: function(size){\n            if (size * 1 == size){\n                //the size is a number\n                size = { width: size, height: size}\n            } else {\n                size.width = size.height\n            }\n\n            this.callSuper()\n        },\n\n        setHeight: function(h){\n           //callSuper will automatically pass the arguments to Rectangle.setHeight, so h will be forwarded\n           this.callSuper()  //or you could use this.callSuperWith(10) if you want to manually pass parameters\n           this.setWidth(h)\n        }\n    })\n```\nYou can also use ```callSuperWith``` and ```callOverridenWith``` to manually pass all parameters\n\nExample\n```js\n//...\nsetHeight: function(h){\n    this.callSuperWith(h*2)\n}\n//...\n```\n\n## Getters and setters\n\nYou can use getters and setters on ```classy``` defined classes. They even work well with ```callSuper``` and ```callOverriden```\n\n```js\nvar Randomer = classy.define({\n    min: 0,\n    max: 10,\n\n    //returns a random float\n    get random(){\n        return Math.random() * (this.max - this.min) + this.min\n    }\n})\n\nRandomer.override({\n    //returns a random int\n    get random(){\n        return Math.floor(\n                    this.callOverriden() //call overriden method\n                )\n    }\n})\n\nvar r = new Randomer()\nr.random // generates a random int between 0 and 10\n```\n\n## forceInstance\n\nYou may want your classes to be usable without the `new` operator. Just specify `forceInstance: true` on the class prototype, and the constructor will be called with `new` if it hasn't been\n\nExample\n\n```js\nvar Vehicle = class.define({\n    forceInstance: true,\n    init: function(name){\n        this.name = name\n    }\n})\nvar v = Vehicle('car')  // since 'forceInstance' is true,\n                        //the Vehicle will be called as a constructor under the hood, so new Vehicle('car')\n```\n## Mixins\n\nClassy offers the ability to mix objects into other objects. At a base level, you can either use simple objects as mixins or you can define mixin classes.\n\nExample\n```js\nvar logger = {\n    $after: {\n        log: function(msg){\n            console.log(msg)\n        }\n    }\n}\n\nvar person = { firstName: 'Bob', lastName: 'Johnson' }\n\nclassy.mixin(person /* target object */, logger /* mixin */)\n```\nin the example above, the person object receives a log function property. Note the usage of $after. Other valid mixin behaviors are ```$copyIf```, ```$before``` and ```$override```.\n\nThese behaviors determine how mixin properties that are functions are mixed-in when the target object already has those properties.\n\n### $copyIf\nAny property in the mixin is copied onto the target object only if the target object does not already have a property with the same name\n\nExample\n```js\nvar logger = {\n    $copyIf: {\n        isLogger: true,\n        log: function(msg){ console.log(msg) },\n        greet: function(msg){ console.log('hello ' + msg) }\n    }\n}\nvar person = {\n    greet: function(msg){\n        alert('Hi ' + msg)\n    }\n}\n\nclassy.mixin(person, logger)\nperson.greet('Bob') //will alert 'Hi Bob' - so logger.greet is not copied, since it already existed on person\nperson.log('warning') //will console.log 'warning' - logger.log was copied to person, since person.log was undefined\nperson.isLogger === true\n```\n\n### $before & $after\n```js\nclassy.defineMixin({\n    alias: 'logger',\n    $before: {\n        log: function(msg){\n            console.log(msg)\n        },\n        warn: function(warning){\n            console.warn(warning)\n            return '!'\n        }\n    }\n})\n\nvar person = {\n    log: function(msg){ alert(msg); return 1}\n}\n\nclassy.mixin(person, 'logger')\n\nperson.log('hi') === 1 // will first console.log('hi') and then will alert('hi')\n//and will return the return value of the initial person.log implementation\nperson.warn('hi') === '!' //will console.warn('hi')\n```\nIn the above example, since log and warn ar copied with a before behavior, first of all classy checks to see if person already has those properties. Since person.log exists, person.log is assigned another function, which calls ```logger.log``` before ```person.log```, and returns the result of the initial ```person.log```.\nFor logger.warn, no such property exists on person, so it is simply assigned to the person.\n\nThe behavior of after is similar, with the difference that the mixin function is called after the initial implementation. The result is that of the initial implementation, if one exists.\n\n### $override\n```\nclassy.defineMixin({\n    alias: 'logger',\n\n    $override: {\n        log: function(msg){ console.log(msg) },\n        warn: function(msg){\n            console.log(msg)\n            return this.callTarget() //call the target object warn implementation, if one exists\n        }\n    }\n})\n\nvar Person = classy.define({\n    alias: 'person',\n    mixins: [\n        'logger'\n    ],\n\n    name: 'bob',\n    warn: function(msg){\n        alert(msg)\n        return this\n    }\n})\n\nvar p = new Person()\np.log(p.name) //simply calls logger.log\np.warn(p.name) // logs p.name and then alerts p.name\n```\n\nNotice that ```logger.warn``` calls ```this.callTarget()``` which means the mixin tries to call the method from the target object that this function has overriden. Since person.warn had an implementation, the logger calls that.\n\n## Static properties and ```$ownClass```\n\nYou can easily define static properties for classes.\n\n```js\nvar Widget = classy.define({\n\n    statics: {\n\n        idSeed: 0,\n\n        getDescription: function(){\n            return 'A Widget class'\n        },\n\n        getNextId: function(){\n            return this.idSeed++\n        }\n    },\n\n    init: function(){\n        this.id = this.$ownClass.getNextId()\n    }\n})\n\nWidget.getDescription() == 'A Widget class' // === true\n\nvar w = new Widget()\nw.id === 0\n\nw = new Widget()\nw.id === 1\n```\n\nOn every instance, you can use the $ownClass property in order to get a reference to the class that created the instance.\n\n## Building\n\nIn order to build a browser version, run ```npm run build```.\n\nThis will use browserify to make a one-file browser build, which you can find in ```dist/classy.js```\n\n## Testing\n\nAfter cloning the repo, make sure you ```npm install```.\n\nThen just run ```npm run test``` or ```make```.\nMake sure you build before you test, since testing is done on a browser build, with karma test runner. To build, ```npm run build```\n\n\n",
  "readmeFilename": "README.md",
  "_id": "classy@1.4.10",
  "dist": {
    "shasum": "f2f1c61e45b19b0e9d87780a769fafd516cc7e34"
  },
  "_from": "classy@^1.4.0",
  "_resolved": "https://registry.npmjs.org/classy/-/classy-1.4.10.tgz"
}
